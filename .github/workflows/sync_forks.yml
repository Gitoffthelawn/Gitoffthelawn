name: "Sync forks"

on:
  # Allow manual triggers from the 'Actions' tab
  workflow_dispatch:
  
  # Automate the run at 02:17 UTC every day
  # The offset helps avoid peak GitHub traffic congestion
  schedule:
    - cron: '17 2 * * *' 

jobs:
  sync-logic:
    runs-on: ubuntu-latest
    steps:
      - name: "Triage and Sync All Branches"
        uses: actions/github-script@v7
        env:
          # Inject secret Fine-grained Token as an environment variable
          SYNC_TOKEN: ${{ secrets.SYNC_TOKEN }}
        with:
          # Set the authenticated client to use specific token
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            // 1. DATA STRUCTURES & INITIALIZATION
            const results = []; // Stores results for the final report
            const stats = { synced: 0, upToDate: 0, ahead: 0, failed: 0 };
            const delay = ms => new Promise(res => setTimeout(res, ms)); 
            
            // 2. API QUOTA MONITORING
            // Tracking start quota helps diagnose if the process was cut short by API limits
            const initialRate = await github.rest.rateLimit.get();
            const startQuota = initialRate.data.resources.core.remaining;

            // 3. REPOSITORY DISCOVERY (PAGINATED)
            // Automatically handle the pagination of large number of repositories
            const forks = await github.paginate(github.rest.repos.listForAuthenticatedUser, {
              affiliation: 'owner', 
              per_page: 100         
            }).then(repos => repos.filter(r => r.fork)); 

            if (!forks || forks.length === 0) {
              await core.summary.addRaw("‚ú® No forks detected.").write();
              return;
            }

            console.log(`üöÄ Starting sync of ${forks.length} forks.`);

            // 4. MAIN PROCESSING LOOP
            for (const [index, fork] of forks.entries()) {
              const currentPos = index + 1;
              const dBranch = fork.default_branch; // Snapshots 'main' or 'master' name
              
              // Progress logging in the Actions console
              if (currentPos % 20 === 0 || currentPos === forks.length) {
                console.log(`[${currentPos}/${forks.length}] Processing: ${fork.full_name}`);
              }

              try {
                // Fetch full metadata to find the parent (upstream) link
                const { data: repoDetail } = await github.rest.repos.get({ 
                  owner: fork.owner.login, repo: fork.name 
                });

                // Check branch count for every fork
                const branches = await github.paginate(github.rest.repos.listBranches, {
                  owner: fork.owner.login, repo: fork.name
                });
                if (branches.length >= 20) {
                  console.log(`Fork with many branches (${branches.length}): ${fork.full_name}`);
                }
                
                // --- CASE: ORPHAN REPOSITORY ---
                if (!repoDetail.parent) {
                  results.push([fork.full_name, "‚ö†Ô∏è ORPHAN", "No upstream parent found"]);
                  stats.ahead++;
                  continue;
                }

                const uOwner = repoDetail.parent.owner.login;
                const uRepo = repoDetail.parent.name;

                // Only triage if fork >50% larger than upstream (never skip if upstream larger)
                const forkSize = repoDetail.size ?? 0;
                const upstreamSize = repoDetail.parent.size ?? 0;
                if (forkSize > 0 && upstreamSize > 0 && forkSize > (upstreamSize * 1.5)) {
                  stats.ahead++;
                  results.push([
                    fork.full_name,
                    "‚ö†Ô∏è TRIAGE",
                    `Fork oversized (${forkSize}KB vs upstream ${upstreamSize}KB)`
                  ]);
                  continue;
                }

                // 5. UPSTREAM COMPARISON (GATEKEEPER)
                let comp;
                try {
                  comp = await github.rest.repos.compareCommits({
                    owner: uOwner, repo: uRepo,
                    base: dBranch,
                    head: `${fork.owner.login}:${dBranch}`
                  });
                } catch (e) {
                  // Catch cases where upstream is deleted or private (404)
                  if (e.status === 404) {
                    results.push([fork.full_name, "‚ùå FAIL", `Upstream @${uOwner} hidden`]);
                    stats.failed++;
                    continue;
                  }
                  throw e;
                }

                // --- CASE: FORK IS AHEAD (DIVERGED) ---
                if (comp.data.ahead_by > 0) {
                  stats.ahead++;
                  results.push([fork.full_name, "‚ö†Ô∏è TRIAGE", `Fork ahead by ${comp.data.ahead_by} commits`]);
                  continue;
                }

                // --- CASE: UP-TO-DATE ---
                if (comp.data.behind_by === 0) {
                  stats.upToDate++;
                  results.push([fork.full_name, "‚ûñ UP-TO-DATE", ""]);
                  continue; 
                }

                // 6. DEEP SYNC (ALL BRANCHES)
                // If the default branch is behind, attempt to sync all branches
                // Note: branches already fetched above, can reuse if needed

                let branchSyncs = 0;
                let branchConflicts = 0;

                for (const b of branches) { // Syncs all branches (add a cap if rate limited)
                  try {
                    const res = await github.request('POST /repos/{owner}/{repo}/merge-upstream', {
                      owner: fork.owner.login, repo: fork.name,
                      data: { branch: b.name }
                    });

                    // Accept 200/202 status codes
                    if (res.status >= 200 && res.status < 300) {
                      if (res.data.merge_type === 'fast-forward') {
                        branchSyncs++;
                      }
                      // 100ms delay to prevent Secondary Rate Limit triggers
                      await delay(100); 
                    }
                  } catch (e) {
                    // 409 status indicates manual intervention is required
                    if (e.status === 409) branchConflicts++;
                  }
                }
                
                stats.synced++;
                const branchWord = branches.length === 1 ? "branch" : "branches";
                let note = `Updated ${branchSyncs}/${branches.length} ${branchWord}`;
                if (branchConflicts > 0) note += ` (${branchConflicts} skipped - conflicts)`;
                results.push([fork.full_name, "‚úÖ SYNCED", note]);

                // 7. QUOTA SAFETY VALVE
                // Stop early if quota hits 400 to allow the report to write successfully
                if (currentPos % 25 === 0) {
                  const rate = await github.rest.rateLimit.get();
                  if (rate.data.resources.core.remaining < 400) {
                    results.push(["SYSTEM", "üõë HALTED", "Quota Buffer Reached"]);
                    break;
                  }
                }

              } catch (err) {
                stats.failed++;
                // Strip special Markdown characters from error messages to preserve table formatting
                const safeErr = (err.message || "Error").replace(/[|`]/g, "").substring(0, 45);
                results.push([fork.full_name, "‚ùå FAIL", safeErr]);
              }
            }

            // 8. FINAL REPORT GENERATION
            const finalRate = await github.rest.rateLimit.get();
            const totalProcessed = stats.synced + stats.upToDate + stats.ahead + stats.failed;

            core.summary
              .addHeading("üîÑ Sync Report")
              .addRaw(`Quota Usage: ${startQuota} ‚Üí ${finalRate.data.resources.core.remaining} | Used: ${Math.max(0, startQuota - finalRate.data.resources.core.remaining)}\n`)
              .addRaw(`<br>‚úÖ Synced: ${stats.synced} | ‚ûñ Up-to-Date: ${stats.upToDate} (hidden from table below) | ‚ö†Ô∏è Ahead: ${stats.ahead} | ‚ùå Errors: ${stats.failed}\n`);

            // 9. EXCEPTION-ONLY FILTERING
            // Hide the 'Up-to-Date' rows to make the report easy to visually scan
            // using a top-level async function or ensure surrounding function is async
            const clean = s => String(s ?? '').trim().replace(/[\u200B-\u200F\uFEFF\u00A0]/g, '');

            const exceptions = results.filter(r => r[1] !== "‚ûñ UP-TO-DATE");

            if (exceptions.length === 0) {
              await core.summary
                .addRaw(`\n‚ú® **All ${forks.length} forks are perfectly in sync.**\n`)
                .write();
            } else {
              const exceptionRows = exceptions.slice(0, 1000).map(row => {
                const repo = clean(row[0]); // "owner/repo"
                return [`https://github.com/${repo}`, clean(row[1]), clean(row[2])];
              });

              await core.summary
                .addRaw(`\nüìù Required Actions (${exceptions.length} items):\n`) // plain text only
                .addTable([
                  [{data: 'Repository', header: true}, {data: 'Status', header: true}, {data: 'Notes', header: true}],
                  ...exceptionRows
                ])
                .write();
            }
