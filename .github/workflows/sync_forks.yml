name: "Sync forks"

on:
  workflow_dispatch:

jobs:
  sync-all-forks:
    runs-on: ubuntu-latest
    steps:
      - name: "Sync All Forks via API"
        uses: actions/github-script@v7
        env:
          # Restored your established secret name
          SYNC_TOKEN: ${{ secrets.SYNC_TOKEN }}
        with:
          # Mapping the secret to the action's required input
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            const results = [];
            const stats = { synced: 0, upToDate: 0, blocked: 0, failed: 0 };
            
            console.log("ðŸ” Fetching repository list...");
            let allRepos;
            try {
              allRepos = await github.paginate(github.rest.repos.listForAuthenticatedUser, {
                affiliation: 'owner',
                per_page: 100
              });
            } catch (e) {
              core.setFailed(`Failed: ${e.message}. Verify SYNC_TOKEN exists in Secrets.`);
              return;
            }
            
            const forks = allRepos.filter(r => r.fork === true);
            console.log(`ðŸš€ Found ${forks.length} forks. Processing...`);

            for (const fork of forks) {
              const fOwner = fork.owner.login;
              const fRepo = fork.name;
              let status = "Up-to-date";
              let detail = "";

              try {
                // Quota Audit: Stop at 60 points to guarantee summary save
                const { data: rate } = await github.rest.rateLimit.get();
                if (rate.resources.core.remaining < 60) {
                  results.push(["SYSTEM", "âš ï¸ HALTED", "Quota Limit"]);
                  break;
                }

                // Safety Audit: Dynamic branch and size detection
                const { data: repoData } = await github.rest.repos.get({ owner: fOwner, repo: fRepo });
                
                if (repoData.parent) {
                  const pSize = repoData.parent.size;
                  const fSize = repoData.size;

                  if (pSize < (fSize / 2) && fSize > 100) {
                    status = "ðŸ›‘ BLOCK";
                    detail = `Upstream (${pSize}KB) < 50%`;
                    stats.blocked++;
                  } else {
                    try {
                      // Execution: branch-agnostic sync
                      const syncResponse = await github.request('POST /repos/{owner}/{repo}/merge-upstream', {
                        owner: fOwner,
                        repo: fRepo,
                        data: {
                          branch: repoData.default_branch
                        }
                      });
                      
                      if (syncResponse.status === 200 || syncResponse.status === 204) {
                        status = "âœ… SYNC";
                        stats.synced++;
                      }
                    } catch (e) {
                      if (e.status === 409) {
                        stats.upToDate++;
                      } else { throw e; }
                    }
                  }
                } else { stats.upToDate++; }
              } catch (err) {
                status = "âŒ FAIL";
                detail = err.message.substring(0, 35);
                stats.failed++;
              }
              
              if (status !== "Up-to-date") {
                results.push([fork.full_name, status, detail]);
                console.log(`[${stats.synced + stats.upToDate + stats.blocked + stats.failed}/${forks.length}] ${fork.full_name}: ${status}`);
              }
            }

            // Summary Table: Optimized for 32KB buffer (1,100 rows)
            const displayResults = results.slice(0, 1100);
            await core.summary
              .addHeading("ðŸ”„ Sync Report")
              .addRaw(`**Total Forks:** ${forks.length} | âœ… **Sync:** ${stats.synced} | âž– **Up-to-Date:** ${stats.upToDate} | ðŸ›‘ **Block:** ${stats.blocked} | âŒ **Err:** ${stats.failed}`)
              .addTable([
                [{data: 'Repo', header: true}, {data: 'Stat', header: true}, {data: 'Note', header: true}],
                ...displayResults
              ])
              .write();
