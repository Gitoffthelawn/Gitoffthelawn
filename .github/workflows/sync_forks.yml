name: "Sync forks"

on:
  # Allow manual triggers from the 'Actions' tab
  workflow_dispatch:
  
  # Automate the run at 02:17 UTC every day
  # The offset helps avoid peak GitHub traffic congestion
  schedule:
    - cron: '16 3 * * *' 

jobs:
  sync-logic:
    runs-on: ubuntu-latest
    steps:
      - name: "Triage and Sync All Branches"
        uses: actions/github-script@v7
        env:
          # Inject secret Fine-grained Token as an environment variable
          SYNC_TOKEN: ${{ secrets.SYNC_TOKEN }}
        with:
          # Set the authenticated client to use specific token
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            // 1. DATA STRUCTURES & INITIALIZATION
            const results = []; // Stores results for the final report
            const stats = { synced: 0, upToDate: 0, ahead: 0, failed: 0 };
            const delay = ms => new Promise(res => setTimeout(res, ms)); 
            
            // 2. API QUOTA MONITORING
            // Tracking start quota helps diagnose if the process was cut short by API limits
            const initialRate = await github.rest.rateLimit.get();
            const startQuota = initialRate.data.resources.core.remaining;

            // 3. REPOSITORY DISCOVERY (PAGINATED)
            // Automatically handle the pagination of large number of repositories
            const forks = await github.paginate(github.rest.repos.listForAuthenticatedUser, {
              affiliation: 'owner', 
              per_page: 100         
            }).then(repos => repos.filter(r => r.fork)); 

            if (!forks || forks.length === 0) {
              await core.summary.addRaw("‚ú® No forks detected.").write();
              return;
            }

            console.log(`üöÄ Starting sync of ${forks.length} forks.`);

            // 4. MAIN PROCESSING LOOP
            for (const [index, fork] of forks.entries()) {
              const currentPos = index + 1;
              const dBranch = fork.default_branch; // Snapshots 'main' or 'master' name
              
              // Progress logging in the Actions console
              if (currentPos % 10 === 0 || currentPos === forks.length) {
                console.log(`[${currentPos}/${forks.length}] Processing: ${fork.full_name}`);
              }

              try {
                // Fetch full metadata to find the parent (upstream) link
                const { data: repoDetail } = await github.rest.repos.get({ 
                  owner: fork.owner.login, repo: fork.name 
                });
                
                // --- CASE: ORPHAN REPOSITORY ---
                if (!repoDetail.parent) {
                  results.push([fork.full_name, "‚ö†Ô∏è ORPHAN", "No upstream parent found"]);
                  stats.ahead++;
                  continue;
                }

                const uOwner = repoDetail.parent.owner.login;
                const uRepo = repoDetail.parent.name;

                // 5a. REPO SIZE SAFETY CHECK (fork vs upstream)
                // GitHub's repo `size` is the total size of all files at the latest commit, in KB.
                const forkSize = repoDetail.size ?? 0;
                const upstreamSize = repoDetail.parent.size ?? 0;

                // If sizes are known and the fork differs from upstream by more than 50%, skip syncing.
                if (forkSize > 0 && upstreamSize > 0) {
                  const sizeRatio = forkSize / upstreamSize;
                  const inverseRatio = upstreamSize / forkSize;

                  // Treat either direction as "> 50% difference":
                  // - fork more than 1.5x upstream
                  // - or upstream more than 1.5x fork
                  if (sizeRatio > 1.5 || inverseRatio > 1.5) {
                    stats.ahead++;
                    results.push([
                      fork.full_name,
                      "‚ö†Ô∏è TRIAGE",
                      `Repo size diverged by more than 50% (fork=${forkSize}KB, upstream=${upstreamSize}KB)`
                    ]);
                    continue;
                  }
                }

                // 5. UPSTREAM COMPARISON (GATEKEEPER)
                let comp;
                try {
                  comp = await github.rest.repos.compareCommits({
                    owner: uOwner, repo: uRepo,
                    base: dBranch,
                    head: `${fork.owner.login}:${dBranch}`
                  });
                } catch (e) {
                  // Catch cases where upstream is deleted or private (404)
                  if (e.status === 404) {
                    results.push([fork.full_name, "‚ùå FAIL", `Upstream @${uOwner} hidden`]);
                    stats.failed++;
                    continue;
                  }
                  throw e;
                }

                // --- CASE: FORK IS AHEAD (DIVERGED) ---
                if (comp.data.ahead_by > 0) {
                  stats.ahead++;
                  results.push([fork.full_name, "‚ö†Ô∏è TRIAGE", `Fork ahead by ${comp.data.ahead_by} commits`]);
                  continue;
                }

                // --- CASE: UP-TO-DATE ---
                if (comp.data.behind_by === 0) {
                  stats.upToDate++;
                  results.push([fork.full_name, "‚ûñ UP-TO-DATE", ""]);
                  continue; 
                }

                // 6. DEEP SYNC (ALL BRANCHES)
                // If the default branch is behind, attempt to sync all branches
                const branches = await github.paginate(github.rest.repos.listBranches, {
                  owner: fork.owner.login, repo: fork.name
                });

                let branchSyncs = 0;
                let branchConflicts = 0;

                for (const b of branches) {
                  try {
                    const res = await github.request('POST /repos/{owner}/{repo}/merge-upstream', {
                      owner: fork.owner.login, repo: fork.name,
                      data: { branch: b.name }
                    });

                    // Accept 200/202 status codes
                    if (res.status >= 200 && res.status < 300) {
                      if (res.data.merge_type === 'fast-forward') {
                        branchSyncs++;
                      }
                      // 100ms delay to prevent Secondary Rate Limit triggers
                      await delay(100); 
                    }
                  } catch (e) {
                    // 409 status indicates manual intervention is required
                    if (e.status === 409) branchConflicts++;
                  }
                }
                
                stats.synced++;
                const branchWord = branchSyncs === 1 ? "branch" : "branches";
                let note = `Updated ${branchSyncs} ${branchWord}`;
                if (branchConflicts > 0) note += ` (${branchConflicts} skipped - conflicts)`;
                results.push([fork.full_name, "‚úÖ SYNCED", note]);

                // 7. QUOTA SAFETY VALVE
                // Stop early if quota hits 400 to allow the report to write successfully
                if (currentPos % 25 === 0) {
                  const rate = await github.rest.rateLimit.get();
                  if (rate.data.resources.core.remaining < 400) {
                    results.push(["SYSTEM", "üõë HALTED", "Quota Buffer Reached"]);
                    break;
                  }
                }

              } catch (err) {
                stats.failed++;
                // Strip special Markdown characters from error messages to preserve table formatting
                const safeErr = (err.message || "Error").replace(/[|`]/g, "").substring(0, 45);
                results.push([fork.full_name, "‚ùå FAIL", safeErr]);
              }
            }

            // 8. FINAL REPORT GENERATION
            const finalRate = await github.rest.rateLimit.get();
            const totalProcessed = stats.synced + stats.upToDate + stats.ahead + stats.failed;

            let summary = core.summary.addHeading("üîÑ Sync Report");
            summary.addRaw(`Quota Usage: ${startQuota} ‚Üí ${finalRate.data.resources.core.remaining} | Used: ${Math.max(0, startQuota - finalRate.data.resources.core.remaining)}\n`);
            summary.addRaw(`<br>‚úÖ Synced: ${stats.synced} | ‚ûñ Up-to-Date: ${stats.upToDate} (Hidden) | ‚ö†Ô∏è Ahead: ${stats.ahead} | ‚ùå Errors: ${stats.failed}\n`);

            // 9. EXCEPTION-ONLY FILTERING
            // Hide the 'Up-to-Date' rows to make the report easy to visually scan
            const exceptions = results.filter(r => r[1] !== "‚ûñ UP-TO-DATE");

            if (exceptions.length === 0) {
              summary.addRaw(`<br>‚ú® **All ${forks.length} forks are perfectly in sync.**`);
              await summary.write();
            } else {
              // Map exceptions so the Repository cell is a Markdown link
              const exceptionRows = exceptions.slice(0, 1000).map(row => {
                const fullName = String(row[0]);      // e.g. "user/repo"
                const status = row[1];
                const notes = row[2] ?? "";

                const repoUrl = `https://github.com/${fullName}`;
                const linkedRepo = `[${fullName}](${repoUrl})`;

                return [linkedRepo, status, notes];
              });

              summary.addRaw(`<br>üìù Required Actions (${exceptions.length} items):\n`);
              // Write the results table, capped at 1,000 exceptions to prevent UI lag
              await summary
                .addTable([
                  [
                    { data: 'Repository', header: true },
                    { data: 'Status', header: true },
                    { data: 'Notes', header: true }
                  ],
                  ...exceptionRows
                ])
                .write();
            }
