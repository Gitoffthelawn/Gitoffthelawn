name: "Sync forks"

on:
  # Manual maintenance trigger
  workflow_dispatch:
  
  # Automated run: 04:17 UTC every Wednesday morning
  schedule:
    - cron: '17 4 * * 3' 

jobs:
  sync-logic:
    runs-on: ubuntu-latest
    steps:
      - name: "Triage and Sync"
        uses: actions/github-script@v7
        env:
          SYNC_TOKEN: ${{ secrets.SYNC_TOKEN }}
        with:
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            const results = [];
            const stats = { synced: 0, upToDate: 0, ahead: 0, failed: 0 };
            const delay = ms => new Promise(res => setTimeout(res, ms));
            
            // 1. Quota Initialization
            const initialRate = await github.rest.rateLimit.get();
            const startQuota = initialRate.data.resources.core.remaining;

            // 2. Initial List Generation
            const forks = await github.paginate(github.rest.repos.listForAuthenticatedUser, {
              affiliation: 'owner', per_page: 100
            }).then(repos => repos.filter(r => r.fork));

            console.log(`üöÄ Starting 1,000-Pass Audited Sync of ${forks.length} forks.`);
            console.log(`üìä Initial Quota: ${startQuota}`);

            for (const [index, fork] of forks.entries()) {
              const currentPos = index + 1;
              
              // Progress Logging (Every 10 repos for live heartbeat)
              if (currentPos % 10 === 0 || currentPos === forks.length) {
                console.log(`[${currentPos}/${forks.length}] Audit In-Progress: ${fork.full_name}`);
              }

              try {
                const { data: repoDetail } = await github.rest.repos.get({ owner: fork.owner.login, repo: fork.name });
                if (!repoDetail || !repoDetail.parent) continue;

                // 3. REPO-LEVEL GATEKEEPER (The Quota Saver)
                const comp = await github.rest.repos.compareCommits({
                  owner: repoDetail.parent.owner.login,
                  repo: repoDetail.parent.name,
                  base: fork.default_branch,
                  head: `${fork.owner.login}:${fork.default_branch}`
                });

                // CASE: DIVERGED - Custom work/PR detected on root
                if (comp.data.ahead_by > 0) {
                  stats.ahead++;
                  results.push([fork.full_name, "‚ö†Ô∏è TRIAGE", `Root branch '${fork.default_branch}' ahead by ${comp.data.ahead_by}.`]);
                  continue;
                }

                // CASE: UP TO DATE - No work needed
                if (comp.data.behind_by === 0) {
                  stats.upToDate++;
                  continue; 
                }

                // CASE: BEHIND - Deep sync all branches
                const branches = await github.paginate(github.rest.repos.listBranches, {
                  owner: fork.owner.login, repo: fork.name
                });

                let branchSyncs = 0;
                let branchConflicts = 0;

                for (const b of branches) {
                  try {
                    const res = await github.request('POST /repos/{owner}/{repo}/merge-upstream', {
                      owner: fork.owner.login, repo: fork.name,
                      data: { branch: b.name }
                    });

                    if (res.status === 200 && res.data.merge_type === 'fast-forward') {
                      branchSyncs++;
                      await delay(150); // Mandatory pause for secondary rate limit health
                    }
                  } catch (e) {
                    if (e.status === 409) branchConflicts++;
                  }
                }
                
                stats.synced++;
                let note = `Updated ${branchSyncs} branch(es).`;
                if (branchConflicts > 0) note += ` (${branchConflicts} skipped - custom commits)`;
                results.push([fork.full_name, "‚úÖ SYNCED", note]);

                // 4. PERIODIC QUOTA & SAFETY HALT
                if (currentPos % 25 === 0) {
                  const rate = await github.rest.rateLimit.get();
                  if (rate.data.resources.core.remaining < 500) {
                    console.log("üõë SAFETY HALT: Quota near exhaustion.");
                    results.push(["SYSTEM", "üõë HALTED", `Quota reached 500 buffer. Remaining: ${rate.data.resources.core.remaining}`]);
                    break;
                  }
                }

              } catch (err) {
                stats.failed++;
                let msg = err.message || "Network/API Error";
                if (msg.length > 50) msg = msg.substring(0, 47) + "...";
                results.push([fork.full_name, "‚ùå FAIL", msg]);
              }
            }

            // 5. SUMMARY WITH TRUNCATION INDICATORS
            const finalRate = await github.rest.rateLimit.get();
            const endQuota = finalRate.data.resources.core.remaining;
            const totalProcessed = stats.synced + stats.upToDate + stats.ahead + stats.failed;

            let summary = core.summary.addHeading("üîÑ 1,000-Pass Fully Audited Sync Report");
            
            summary.addRaw(`**API Quota Monitoring:** ${startQuota} (Start) ‚Üí ${endQuota} (End) | **Used:** ${startQuota - endQuota}\n`);
            summary.addRaw(`<br>‚úÖ **Syncs:** ${stats.synced} | ‚ûñ **Up-to-Date:** ${stats.upToDate} | ‚ö†Ô∏è **Ahead:** ${stats.ahead} | ‚ùå **Errors:** ${stats.failed}\n`);

            if (results.length > 1000 || totalProcessed < forks.length) {
              summary.addRaw(`<br>‚ö†Ô∏è **TRUNCATION NOTICE:** Report capped at 1,000 items. Processed: ${totalProcessed}/${forks.length} forks.\n`);
            }

            await summary.addTable([
                [{data: 'Repository', header: true}, {data: 'Status', header: true}, {data: 'Notes', header: true}],
                ...results.slice(0, 1000)
            ]).write();
