name: "Sync forks"

on:
  workflow_dispatch:

jobs:
  sync-all-forks:
    runs-on: ubuntu-latest
    steps:
      - name: "Sync All Forks via API"
        uses: actions/github-script@v7
        env:
          SYNC_TOKEN: ${{ secrets.SYNC_TOKEN }}
        with:
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            const results = [];
            const stats = { synced: 0, upToDate: 0, blocked: 0, failed: 0 };
            
            console.log("ğŸ” Fetching full repository list...");
            const allRepos = await github.paginate(github.rest.repos.listForAuthenticatedUser, {
              affiliation: 'owner',
              per_page: 100
            });
            
            const forks = allRepos.filter(r => r.fork === true);
            console.log(`ğŸš€ Auditing ${forks.length} forks...`);

            for (const fork of forks) {
              const fOwner = fork.owner.login;
              const fRepo = fork.name;
              let status = "Up-to-date";
              let detail = "";

              try {
                // Quota Check (Pass 7 Audit)
                const rate = await github.rest.rateLimit.get();
                if (rate.data.resources.core.remaining < 50) {
                  results.push(["SYSTEM", "âš ï¸ HALTED", "Quota Limit"]);
                  break;
                }

                const { data: repoData } = await github.rest.repos.get({ owner: fOwner, repo: fRepo });
                
                if (repoData.parent) {
                  const pSize = repoData.parent.size;
                  const fSize = repoData.size;

                  // Safety Gate
                  if (pSize < (fSize / 2) && fSize > 100) {
                    status = "ğŸ›‘ BLOCK";
                    detail = `${pSize}KB vs ${fSize}KB`;
                    stats.blocked++;
                  } else {
                    try {
                      const res = await github.request('POST /repos/{owner}/{repo}/merge-upstream', {
                        owner: fOwner, repo: fRepo,
                        data: { branch: repoData.default_branch }
                      });
                      
                      // LOGICAL IMPROVEMENT: Validating actual merge activity
                      if (res.status === 200 && res.data?.merge_type && res.data.merge_type !== 'none') {
                        status = "âœ… SYNC";
                        detail = res.data.merge_type;
                        stats.synced++;
                      } else {
                        stats.upToDate++;
                      }
                    } catch (e) {
                      if (e.status === 409) { 
                        stats.upToDate++; 
                      } else { throw e; }
                    }
                  }
                }
              } catch (err) {
                status = "âŒ FAIL";
                // ERROR AUDIT: Priority extraction of API-specific messages
                const apiMessage = err.response?.data?.message || err.message || "Unknown";
                detail = apiMessage.substring(0, 40);
                stats.failed++;
                console.log(`âŒ ${fRepo}: ${apiMessage}`);
              }
              
              if (status !== "Up-to-date") {
                results.push([fork.full_name, status, detail]);
              }
            }

            // Report Generation (Pass 10 Audit: Buffer safety)
            const displayResults = results.slice(0, 1100);
            await core.summary
              .addHeading("ğŸ”„ Sync Activity Report")
              .addRaw(`âœ… **Sync:** ${stats.synced} | â– **Up-to-Date:** ${stats.upToDate} | ğŸ›‘ **Block:** ${stats.blocked} | âŒ **Err:** ${stats.failed}`)
              .addTable([
                [{data: 'Repo', header: true}, {data: 'Stat', header: true}, {data: 'Note', header: true}],
                ...displayResults
              ])
              .write();
