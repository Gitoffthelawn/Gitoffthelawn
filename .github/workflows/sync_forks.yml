name: "Sync forks"

on:
  # Allows manual triggers from the "Actions" tab
  workflow_dispatch:
  
  # Automates the run at 04:17 UTC every Wednesday morning
  schedule:
    - cron: '17 4 * * 3' 

jobs:
  sync-logic:
    runs-on: ubuntu-latest
    steps:
      - name: "Triage and Sync All Branches"
        uses: actions/github-script@v7
        env:
          SYNC_TOKEN: ${{ secrets.SYNC_TOKEN }}
        with:
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            const results = [];
            const stats = { synced: 0, upToDate: 0, ahead: 0, failed: 0 };
            const delay = ms => new Promise(res => setTimeout(res, ms));
            
            // 1. Initialize API Quota Tracking
            const initialRate = await github.rest.rateLimit.get();
            const startQuota = initialRate.data.resources.core.remaining;

            // 2. Fetch all user repositories (Paginated to handle 1,428 items)
            const forks = await github.paginate(github.rest.repos.listForAuthenticatedUser, {
              affiliation: 'owner', per_page: 100
            }).then(repos => repos.filter(r => r.fork));

            console.log(`üöÄ Starting 1000-Pass Audited Sync of ${forks.length} forks.`);
            console.log(`üìä Initial Quota: ${startQuota}`);

            for (const [index, fork] of forks.entries()) {
              const currentPos = index + 1;
              
              // Progress Logging (Every 10 repos for a live heartbeat)
              if (currentPos % 10 === 0 || currentPos === forks.length) {
                console.log(`[${currentPos}/${forks.length}] Auditing: ${fork.full_name}`);
              }

              try {
                // Fetch full metadata to find the Upstream Parent
                const { data: repoDetail } = await github.rest.repos.get({ owner: fork.owner.login, repo: fork.name });
                
                // --- CASE: ORPHAN (No Parent) ---
                if (!repoDetail.parent || !repoDetail.parent.owner) {
                  results.push([fork.full_name, "‚ö†Ô∏è ORPHAN", "No upstream parent found."]);
                  stats.ahead++; // Categorized here to avoid counting as a 'FAIL'
                  continue;
                }

                const uOwner = repoDetail.parent.owner.login;
                const uRepo = repoDetail.parent.name;

                // 3. GATEKEEPER CHECK: Compare default branch (Quota Saver)
                let comp;
                try {
                  comp = await github.rest.repos.compareCommits({
                    owner: uOwner, repo: uRepo,
                    base: fork.default_branch,
                    head: `${fork.owner.login}:${fork.default_branch}`
                  });
                } catch (e) {
                  if (e.status === 404) {
                    // This handles the "Not Found" error caused by token visibility/org blocks
                    results.push([fork.full_name, "‚ùå FAIL", `Upstream @${uOwner} hidden. Check token permissions.`]);
                    stats.failed++;
                    continue;
                  }
                  throw e;
                }

                // --- CASE: DIVERGED ---
                if (comp.data.ahead_by > 0) {
                  stats.ahead++;
                  results.push([fork.full_name, "‚ö†Ô∏è TRIAGE", `Root branch ahead by ${comp.data.ahead_by}.`]);
                  continue;
                }

                // --- CASE: UP TO DATE ---
                if (comp.data.behind_by === 0) {
                  stats.upToDate++;
                  continue; 
                }

                // --- CASE: BEHIND (Proceed with Deep Sync of All Branches) ---
                const branches = await github.paginate(github.rest.repos.listBranches, {
                  owner: fork.owner.login, repo: fork.name
                });

                let branchSyncs = 0;
                let branchConflicts = 0;

                for (const b of branches) {
                  try {
                    // POST call to the merge-upstream endpoint (Same as clicking "Sync fork" button)
                    const res = await github.request('POST /repos/{owner}/{repo}/merge-upstream', {
                      owner: fork.owner.login, repo: fork.name,
                      data: { branch: b.name }
                    });

                    if (res.status === 200 && res.data.merge_type === 'fast-forward') {
                      branchSyncs++;
                      await delay(150); // Pause to prevent secondary rate limits
                    }
                  } catch (e) {
                    // 409 means the branch has diverged (Sync button would be disabled in UI)
                    if (e.status === 409) branchConflicts++;
                  }
                }
                
                stats.synced++;
                // Applied Smart Pluralization logic
                const branchWord = branchSyncs === 1 ? "branch" : "branches";
                let note = `Updated ${branchSyncs} ${branchWord}.`;
                if (branchConflicts > 0) note += ` (${branchConflicts} skipped - custom commits)`;
                results.push([fork.full_name, "‚úÖ SYNCED", note]);

                // 4. PERIODIC QUOTA & SAFETY HALT
                if (currentPos % 25 === 0) {
                  const rate = await github.rest.rateLimit.get();
                  if (rate.data.resources.core.remaining < 500) {
                    console.log("üõë SAFETY HALT: Quota buffer reached.");
                    results.push(["SYSTEM", "üõë HALTED", `Quota reached 500 buffer. Remaining: ${rate.data.resources.core.remaining}`]);
                    break;
                  }
                }

              } catch (err) {
                stats.failed++;
                let msg = err.message || "Network Error";
                if (msg.length > 50) msg = msg.substring(0, 47) + "...";
                results.push([fork.full_name, "‚ùå FAIL", msg]);
              }
            }

            // 5. FINAL SUMMARY GENERATION
            const finalRate = await github.rest.rateLimit.get();
            const totalProcessed = stats.synced + stats.upToDate + stats.ahead + stats.failed;

            let summary = core.summary.addHeading("üîÑ 1000-Pass Fully Audited Sync Report");
            summary.addRaw(`**API Quota Monitoring:** ${startQuota} ‚Üí ${finalRate.data.resources.core.remaining} (End) | **Used:** ${startQuota - finalRate.data.resources.core.remaining}\n`);
            summary.addRaw(`<br>‚úÖ **Syncs:** ${stats.synced} | ‚ûñ **Up-to-Date:** ${stats.upToDate} | ‚ö†Ô∏è **Ahead/Orphan:** ${stats.ahead} | ‚ùå **Errors:** ${stats.failed}\n`);

            // Add Truncation notice if list is massive
            if (results.length > 1000 || totalProcessed < forks.length) {
              summary.addRaw(`<br>‚ö†Ô∏è **TRUNCATION NOTICE:** Report capped at 1,000 items. Processed: ${totalProcessed}/${forks.length} forks.\n`);
            }

            await summary.addTable([
                [{data: 'Repository', header: true}, {data: 'Status', header: true}, {data: 'Notes', header: true}],
                ...results.slice(0, 1000)
            ]).write();
